import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

def kuramoto_modified(t, y, omega, N, a, C):
    """
    y has dimension N + 1: [theta_0, theta_1, …, theta_{N-1}, K]
    omega: array of shpipape (N,) of natural frequencies
    a, C: logistic growth parameters for K
    """
    thetas = y[:N]
    K = y[N]
    dtheta = np.zeros(N)
    # coupling term
    # compute pairwise sin differences
    # more efficiently:
    sin_diffs = np.sin(thetas[:, None] - thetas[None, :])  # N×N
    sum_sin = np.sum(sin_diffs, axis=1)  # sum over j
    # But note: sin(θ_i - θ_j) = - sin(θ_j - θ_i), so you may choose orientation carefully
    # Using the usual sign convention: \sum_j sin(θ_j - θ_i)
    # So do:
    sum_sin = np.sum(np.sin(thetas[None, :] - thetas[:, None]), axis=1)
    dtheta = omega + (K / N) * sum_sin
    
    # logistic growth for K
    dK = a * K * (1 - K / C)
    
    return np.concatenate((dtheta, [dK]))


def simulate_kuramoto_mod(omega, A, phi0, theta0, K0, a, C, t_span, t_eval):
    """
    omega: natural frequencies (N,)
    A: amplitudes of each oscillator (N,)
    phi0: initial phases of oscillators (N,)
    theta0: initial phases for integration (N,)
    K0: initial coupling
    a, C: logistic parameters
    t_span: (t0, tf)
    t_eval: times at which to sample
    """
    N = len(omega)
    y0 = np.concatenate((theta0, [K0]))
    sol = solve_ivp(kuramoto_modified, t_span, y0, t_eval=t_eval,
                    args=(omega, N, a, C), vectorized=False)
    thetas_t = sol.y[:N, :]  # shape (N, len(t_eval))
    K_t = sol.y[N, :]
    # compute order parameter r(t)
    r_t = np.abs(np.sum(np.exp(1j * thetas_t), axis=0) / N)
    # reconstruct “EEG-like” signal S(t)
    # S(t) = A0/2 + sum_{m=1}^N A_m cos(theta_m(t) + phi0[m])
    # Here A0 is sometimes a DC offset; you may set A0 = 0 if not needed.
    # Let's assume A0 = 0 for simplicity:
    S_t = np.zeros_like(t_eval)
    for m in range(N):
        S_t += A[m] * np.cos(thetas_t[m, :] + phi0[m])
    # Optionally add A0/2 offset if desired
    return t_eval, thetas_t, K_t, r_t, S_t


if __name__ == '__main__':
    # Example / toy parameters
    N = 14
    # Natural frequencies: for demonstration, sample around e.g. some distribution,
    # or use frequencies derived from EEG data as in the paper.
    # For now just random around 10 Hz:
    np.random.seed(0)
    omega = 2 * np.pi * (10 + 0.5 * np.random.randn(N))  # in rad/s
    # amplitudes:
    A = np.abs(np.random.randn(N))
    phi0 = np.random.uniform(0, 2*np.pi, size=N)
    theta0 = np.random.uniform(0, 2*np.pi, size=N)
    K0 = 0.1  # small starting coupling
    a = 0.0065  # growth rate (as in paper) :contentReference[oaicite:6]{index=6}
    C = 75.0    # carrying capacity (max coupling) :contentReference[oaicite:7]{index=7}
    
    tspan = (0.0, 3000.0)  # time in seconds (or arbitrary units)  
    t_eval = np.linspace(tspan[0], tspan[1], 30001)  # sample densely
    
    t, thetas_t, K_t, r_t, S_t = simulate_kuramoto_mod(
        omega, A, phi0, theta0, K0, a, C, tspan, t_eval
    )
    
    # Plot coupling K(t), order parameter r(t), and reconstructed signal
    fig, axs = plt.subplots(3, 1, figsize=(8, 8), sharex=True)
    axs[0].plot(t, K_t, label='K(t)')
    axs[0].axhline(y=C, color='k', ls='--', label='C (max coupling)')
    axs[0].set_ylabel('K')
    axs[0].legend()
    axs[1].plot(t, r_t, label='r(t)')
    axs[1].set_ylabel('r (coherence)')
    axs[1].legend()
    axs[2].plot(t, S_t, label='Simulated EEG‑like S(t)')
    axs[2].set_xlabel('Time')
    axs[2].set_ylabel('Signal')
    axs[2].legend()
    plt.tight_layout()
    plt.show()
